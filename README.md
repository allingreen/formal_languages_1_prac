# formal_languages_1_prac

Алгоритм.
Разбираем выражение в обратной польской записи и имеем в стеке State, которое описывает состояния. Каким образом? State хранит словарь из ключа - остатка по модулю k, а так же значения - интересной нам информации о минимальной длине слова, равной ключу по модулю k.

Как мы добавляем состояния:
  1) если считали букву - добавили {1, 1}
  2) если считали 1 - добавили {0, 0}
  3) если считали . - берем два элемента со стека и получаем новое, складывая остатки по модулю, а так же длины
  4) если считали + - берем минимум из значений для каждого ключа
  5) если считали * - имеем типичную задачу о рюкзаке: k элементов-всевозможных остатков (weight), а также задающую эти остатки длины, т.е. стоимость (cost)
  
INF означает, что для конкретного остатка нет слова с такой длиной по модулю.

Сложность: O(n*k^2) - где n - длина regular expression, а k - дано из условия, т.к. самая дорогостоящая обработка - это обработка * алгоритмом из задачи о рюкзаке.
